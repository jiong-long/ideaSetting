<application>
  <component name="AppStorage">
    <histories>
      <item value="Conditional On Missing Bean" />
      <item value="Conditional" />
      <item value="Detect if the user has created a MultipartResolver but named it incorrectly" />
      <item value="/** * Return the auto-configuration class names that should be considered. By default * this method will load candidates using {@link SpringFactoriesLoader} with * {@link #getSpringFactoriesLoaderFactoryClass()}. * @param metadata the source metadata * @param attributes the {@link #getAttributes(AnnotationMetadata) annotation * attributes} * @return a list of candidate configurations */" />
      <item value="This class can also be subclassed if a custom variant of" />
      <item value="get Bean Definition Names" />
      <item value="CUSTOM" />
      <item value="Talk is cheap. Show me the code." />
      <item value="scale" />
      <item value="/** * Create a new transaction, and suspend the current transaction if one exists. * Analogous to the EJB transaction attribute of the same name. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available to it (which is server-specific in standard Java EE). * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */" />
      <item value="代开发应用" />
      <item value="/** * Any annotations listed here are put on the generated constructor. * The syntax for this feature depends on JDK version (nothing we can do about that; it's to work around javac bugs).&lt;br&gt; * up to JDK7:&lt;br&gt; * {@code @RequiredArgsConstructor(onConstructor=@__({@AnnotationsGoHere}))}&lt;br&gt; * from JDK8:&lt;br&gt; * {@code @RequiredArgsConstructor(onConstructor_={@AnnotationsGohere})} // note the underscore after {@code onConstructor}. * * @return List of annotations to apply to the generated constructor. */" />
      <item value="* Generates a constructor with required arguments. * Required arguments are final fields and fields with constraints such as {@code @NonNull}. * &lt;p&gt; * Complete documentation is found at &lt;a href=&quot;https://projectlombok.org/features/Constructor&quot;&gt;the project lombok features page for &amp;#64;Constructor&lt;/a&gt;. * &lt;p&gt; * Even though it is not listed, this annotation also has the {@code onConstructor} parameter. See the full documentation for more details." />
      <item value="Field injection is not recommended" />
      <item value="wired" />
      <item value="Autowired" />
      <item value="on Constructor" />
      <item value="代开发企业配置解密后为" />
      <item value="convert" />
      <item value="conver" />
      <item value="Encrypt" />
      <item value="侧边栏地址" />
      <item value="/** * Use the default isolation level of the underlying datastore. * All other levels correspond to the JDBC isolation levels. * @see java.sql.Connection */" />
      <item value="/** * Sets the access level of the constructor. By default, generated constructors are {@code public}. * * @return The constructor will be generated with this access modifier. */" />
      <item value="* Any annotations listed here are put on the generated constructor. * The syntax for this feature depends on JDK version (nothing we can do about that; it's to work around javac bugs)." />
      <item value="* Generates a constructor with required arguments. * Required arguments are final fields and fields with constraints such as {@code @NonNull}." />
      <item value="/** * Generates a constructor with required arguments. * Required arguments are final fields and fields with constraints such as {@code @NonNull}. * &lt;p&gt; * Complete documentation is found at &lt;a href=&quot;https://projectlombok.org/features/Constructor&quot;&gt;the project lombok features page for &amp;#64;Constructor&lt;/a&gt;. * &lt;p&gt; * Even though it is not listed, this annotation also has the {@code onConstructor} parameter. See the full documentation for more details. * * @see NoArgsConstructor * @see AllArgsConstructor */" />
      <item value="async" />
      <item value="异步" />
      <item value="negate" />
      <item value="/** * Returns a {@code BigDecimal} whose value is {@code (-this)}, * and whose scale is {@code this.scale()}. * * @return {@code -this}. */" />
      <item value="分页查询的游标，首次调用不填" />
      <item value="Base Response" />
      <item value="transaction" />
      <item value="Propagation" />
      <item value="PROPAGATION SUPPORTS" />
      <item value="PROPAGATION REQUIRED" />
      <item value="/** * Execute within a nested transaction if a current transaction exists, * behave like {@code REQUIRED} otherwise. There is no analogous feature in EJB. * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific * transaction managers. Out of the box, this only applies to the JDBC * DataSourceTransactionManager. Some JTA providers might support nested * transactions as well. * @see org.springframework.jdbc.datasource.DataSourceTransactionManager */" />
      <item value="/** * Support a current transaction, throw an exception if none exists. * Analogous to EJB transaction attribute of the same name. */" />
      <item value="/** * Defines zero (0) or more exception names (for exceptions which must be a * subclass of {@link Throwable}), indicating which exception types must cause * a transaction rollback. * &lt;p&gt;This can be a substring of a fully qualified class name, with no wildcard * support at present. For example, a value of {@code &quot;ServletException&quot;} would * match {@code javax.servlet.ServletException} and its subclasses. * &lt;p&gt;&lt;b&gt;NB:&lt;/b&gt; Consider carefully how specific the pattern is and whether * to include package information (which isn't mandatory). For example, * {@code &quot;Exception&quot;} will match nearly anything and will probably hide other * rules. {@code &quot;java.lang.Exception&quot;} would be correct if {@code &quot;Exception&quot;} * were meant to define a rule for all checked exceptions. With more unusual * {@link Exception} names such as {@code &quot;BaseBusinessException&quot;} there is no * need to use a FQN. * &lt;p&gt;Similar to {@link org.springframework.transaction.interceptor.RollbackRuleAttribute#RollbackRuleAttribute(String exceptionName)}. * @see #rollbackFor * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable) */" />
      <item value="subtract" />
      <item value="Home Inventory Summary Response" />
      <item value="list" />
      <item value="计算日均" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="46" />
        <entry key="ENGLISH" value="47" />
        <entry key="PORTUGUESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20211207001021629" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>